<div class="container content">
	<p>
		Низкоуровневое API которое иногда может быть полезно:
	</p>
	<h2 class="title" id="$refs">
		References - $refs
	</h2>
	<p>
		Название элемента или компонента для регистрации ссылки на него. В объекте $refs появится поле с названием из этого атрибута и значением: элементом DOM, если атрибут стоял на простом теге или экземпляром компонента, если атрибут стоял на пользовательском компоненте:
	</p>
	<docs.code type="html" :code="codeExamples.get('refs')"></docs.code>
	<p>
		При использовании на элементах/компонентах с \@each, регистрируется массив ссылок на элементы DOM или экземпляры компонентов.
	</p>
	<p>
		Важное замечание о времени регистрации ссылок: поскольку ссылки создаются render-функцией, вы не сможете использовать их при первичной отрисовке — на тот момент они ещё не существуют! Кроме того, объект $refs не является реактивным, поэтому не стоит пытаться использовать его в шаблонах для связывания данных.
	</p>
	<h2 class="title" id="el">
		Element - $el
	</h2>
	<p>
		Доступ к корневому элементу или к первому элементу шаблона, если их используется несколько:
	</p>
	<docs.code type="html" :code="codeExamples.get('el')"></docs.code>
	<p>
		Важное замечание о времени регистрации Node элемента: поскольку ссылка создается render-функцией, вы не сможете использовать ее при первичной отрисовке — на тот момент ее ещё не существует!
	</p>
	<h2 class="title" id="$render">
		Render - $render
	</h2>
	<p>
		Переменная $render помогает определить, происходит ли сейчас рендеринг или гидратация элементов.
	</p>
</div>

<script>
export { Layout } from '@layouts/docs.sexy';

let codeExamples = new Map();

codeExamples.set('refs', `
<!-- $refs.p будет DOM-элементом -->
<p ref="p">hello</p>
<!-- $refs.child будет указывать на элемент дочернего компонента -->
<child-component ref="child"></child-component>

<script>
$refs;
</script>
`);

codeExamples.set('el', `
<script>
$el
</script>
`);
</script>