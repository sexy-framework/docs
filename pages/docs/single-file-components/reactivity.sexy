<div class="container content">
	<p>
		Как было сказано ранее, Sexy фреймворк не использует реактивные библиотеки, поэтому есть небольшая особенность в создании реактивных переменных. Они должны быть объявлены явно.
	</p>
	<p>
		Важный момент, любая реактивность объявляется только в корне тега Script. Объявить реактивную переменную внутри функции/метода нельзя. Анализатор вернет ошибку.
	</p>
	<p>
		Любые переменные, методы и функции нельзя называть с $. Так как код не инкапсулируется, возможны конфликты имен и будут возникать ошибки.
	</p>
	<h2 class="title">
		Реактивные переменные
	</h2>
	<p>
		Любая реактивная переменная объявляется в корне, с помощью такой конструкции:
	</p>
	<docs.code type="javascript" code="let counter = o(1)"></docs.code>

	<p>
		Теперь counter – это функция. Чтобы получить значение, которое записано в counter, нужно просто вызвать функцию:
	</p>
	<docs.code type="javascript" code="let counterValue = counter()"></docs.code>

	<p>
		counterValue будет равно 1 и не будет реактивным.
	</p>
	
	<p>
		Чтобы изменить значение counter, после которого запуститься цепочка зависимостей, которые обновят DOM (если counter там используется), необходимо в функцию передать значение:
	</p>
	<docs.code type="javascript" code="counter(2);"></docs.code>

	<p>
		Также и при работе с массивами и объектами. Чтобы изменить значение объекта, его нужно сначала получить, изменить, а потом передать. Кажется избыточным, но на самом деле это не так. Такой подход позволяет защититься от не нужных изменениях DOM из коробки.
	</p>
	<docs.code type="html" :code="codeExamples.get('state')"></docs.code>

	<br>
	<h2 class="title">
		Вычисляемые переменные
	</h2>
	<p>
		Вычисляемые переменные – это переменные, которые используют реактивные переменные для получения какого-то нового значения. Например, фильтр данных.
	</p>
	<docs.code type="html" :code="codeExamples.get('computed')"></docs.code>
	
	<h2 class="title">
		Ожидание изменений реактивных переменных (watch)
	</h2>
	<p>
		За изменениями любой реактивной переменной можно следить и совершать какие-либо действия с помощью метода watch.
	</p>
	<docs.code type="html" :code="codeExamples.get('watch')"></docs.code>
	
</div>

<script>
export { Layout } from '@layouts/docs.sexy';

let codeExamples = new Map();

codeExamples.set('state', `
Let couter = o({ value: 1 })

Let counterValue = counter();
Let realCounterValue = counterValue.value;

counterValue.value = 2; // Так делать не стоит, значение изменится, но обновления DOM не запустятся
counter(counterValue) // поэтому обновим значение явно
`);

codeExamples.set('computed', `
Let counter = o(1);
Let muliplier = () => {
	return counter() * 2;
}

multiplier() // вернет 2
`);

codeExamples.set('watch', `
// some.component script tag with prop
import { watch } from 'sexy-framework/observables';

let str = o('Some str value');

let substr = () => {
	return str.substr(0, 5) + '-changed';
}

watch(str, () => {
	console.log('Variable has changed. New value:', str());
})

watch([substr, str], () => {
  console.log('Some of variable has changed. New value:', substr());
})
`);

</script>